<script type="module">
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.39.3';

const SUPABASE_URL = 'https://bmmaijlbpwgzhrxzxphf.supabase.co';
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJtbWFpamxicHdnemhyeHp4cGhmIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjY4NjQ5MDcsImV4cCI6MjA4MjQ0MDkwN30.s0YQVnAjMXFu1pSI1NXZ2naSab179N0vQPglsmy3Pgw';

const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

let currentUser = null;
let currentGameId = null;
let currentGameCode = null;
let myPlayerNumber = null;
let gameActive = false;
let player1 = null;
let player2 = null;
let gameStateChannel = null;
let waitingChannel = null;
let player1IsReady = false;
let player2IsReady = false;

const themes = {
    classic: { cyan: '#00ffff', yellow: '#ffff00', purple: '#ff00ff', green: '#00ff00', red: '#ff0000', blue: '#0000ff', orange: '#ff8800' }
};

function getColorFromTheme(themeName, colorName) {
    const theme = themes[themeName] || themes.classic;
    return theme[colorName] || theme.cyan;
}

const shapes = [
    {shape: [[1,1,1,1]], color: 'cyan'},
    {shape: [[1,1],[1,1]], color: 'yellow'},
    {shape: [[0,1,0],[1,1,1]], color: 'purple'},
    {shape: [[0,1,1],[1,1,0]], color: 'green'},
    {shape: [[1,1,0],[0,1,1]], color: 'red'},
    {shape: [[1,0,0],[1,1,1]], color: 'blue'},
    {shape: [[0,0,1],[1,1,1]], color: 'orange'}
];

async function loadUserSettings() {
    return { rows: 20, cols: 10, theme: 'classic' };
}

async function loadUser() {
    const saved = localStorage.getItem('currentUser');
    if (saved) {
        try {
            currentUser = JSON.parse(saved);
        } catch (e) {
            currentUser = { username: saved, is_guest: true };
        }
    } else {
        currentUser = { username: 'Host_' + Math.floor(Math.random() * 10000), is_guest: true };
    }
}

function generateGameCode() {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    let code = '';
    for (let i = 0; i < 6; i++) {
        code += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return code;
}

async function createGame() {
    const gameCode = generateGameCode();
    const settings = await loadUserSettings();
    
    try {
        const { data, error } = await supabase
            .from('tetris_multiplayer_games')
            .insert([{
                game_code: gameCode,
                player1_id: currentUser.id || null,
                player1_username: currentUser.username,
                player1_ready: false,
                player2_ready: false,
                player1_map_rows: settings.rows,
                player1_map_cols: settings.cols,
                player1_theme: settings.theme,
                status: 'waiting'
            }])
            .select()
            .single();
        
        if (error) throw error;
        
        currentGameId = data.id;
        currentGameCode = gameCode;
        myPlayerNumber = 1;
        
        document.getElementById('mainMenu').style.display = 'none';
        document.getElementById('waitingRoom').style.display = 'flex';
        document.getElementById('gameCodeText').textContent = gameCode;
        document.getElementById('player1WaitName').textContent = currentUser.username;
        
        waitForBothPlayers();
    } catch (error) {
        console.error('Chyba:', error);
        alert('Chyba pÅ™i vytvÃ¡Å™enÃ­ hry!');
    }
}

function showJoinMenu() {
    document.getElementById('mainMenu').style.display = 'none';
    document.getElementById('joinMenu').style.display = 'flex';
}

async function joinGame() {
    const code = document.getElementById('gameInput').value.trim().toUpperCase();
    
    if (!code || code.length !== 6) {
        alert('Zadej platnÃ½ 6-mÃ­stnÃ½ kÃ³d hry!');
        return;
    }
    
    const settings = await loadUserSettings();
    
    try {
        const { data: game, error: fetchError } = await supabase
            .from('tetris_multiplayer_games')
            .select('*')
            .eq('game_code', code)
            .eq('status', 'waiting')
            .single();
        
        if (fetchError || !game) {
            alert('Hra s tÃ­mto kÃ³dem neexistuje!');
            return;
        }
        
        await supabase
            .from('tetris_multiplayer_games')
            .update({
                player2_id: currentUser.id || null,
                player2_username: currentUser.username,
                player2_map_rows: settings.rows,
                player2_map_cols: settings.cols,
                player2_theme: settings.theme
            })
            .eq('id', game.id);
        
        currentGameId = game.id;
        currentGameCode = code;
        myPlayerNumber = 2;
        
        document.getElementById('joinMenu').style.display = 'none';
        document.getElementById('waitingRoom').style.display = 'flex';
        document.getElementById('gameCodeText').textContent = code;
        document.getElementById('player1WaitName').textContent = game.player1_username;
        document.getElementById('player2WaitName').textContent = currentUser.username;
        document.getElementById('readyBtn').style.display = 'block';
        
        waitForBothPlayers();
    } catch (error) {
        console.error('Chyba:', error);
        alert('Chyba pÅ™i pÅ™ipojovÃ¡nÃ­!');
    }
}

async function waitForBothPlayers() {
    console.log('ÄŒekÃ¡m v mÃ­stnosti, player:', myPlayerNumber);
    
    // Pokud jsem hrÃ¡Ä 1, sleduj kdy pÅ™ijde hrÃ¡Ä 2 a pak zobraz READY tlaÄÃ­tko
    if (myPlayerNumber === 1) {
        const checkInterval = setInterval(async () => {
            const { data: game } = await supabase
                .from('tetris_multiplayer_games')
                .select('*')
                .eq('id', currentGameId)
                .single();
            
            if (game && game.player2_username) {
                clearInterval(checkInterval);
                console.log('HrÃ¡Ä 2 se pÅ™ipojil:', game.player2_username);
                document.getElementById('player2WaitName').textContent = game.player2_username;
                document.getElementById('readyBtn').style.display = 'block';
            }
        }, 1000);
        window.waitInterval = checkInterval;
    }
    
    // Sleduj ready stavy obou hrÃ¡ÄÅ¯ a status hry
    waitingChannel = supabase
        .channel(`waiting_${currentGameId}`)
        .on('postgres_changes', {
            event: 'UPDATE',
            schema: 'public',
            table: 'tetris_multiplayer_games',
            filter: `id=eq.${currentGameId}`
        }, (payload) => {
            console.log('ZmÄ›na stavu hry:', payload.new);
            
            // DÅ®LEÅ½ITÃ‰: VÅ¾dy aktualizuj ready status pÅ™i JAKÃ‰KOLI zmÄ›nÄ›
            updateReadyStatus(payload.new);
            
            // Pokud host spustil odpoÄÃ­tÃ¡vÃ¡nÃ­
            if (payload.new.status === 'countdown' && myPlayerNumber === 2) {
                document.getElementById('readyBtn').style.display = 'none';
                
                const countdownEl = document.getElementById('countdownDisplay');
                countdownEl.style.display = 'block';
                
                let count = 10;
                countdownEl.textContent = count;
                
                const interval = setInterval(() => {
                    count--;
                    if (count > 0) {
                        countdownEl.textContent = count;
                    } else {
                        clearInterval(interval);
                        countdownEl.textContent = 'START!';
                    }
                }, 1000);
            }
            
            // Pokud se zaÄalo hrÃ¡t
            if (payload.new.status === 'playing') {
                setTimeout(() => {
                    startGame();
                }, 500);
            }
        })
        .subscribe();
    
    // NaÄti aktuÃ¡lnÃ­ stav
    const { data: game } = await supabase
        .from('tetris_multiplayer_games')
        .select('*')
        .eq('id', currentGameId)
        .single();
    
    if (game) {
        updateReadyStatus(game);
        // Pokud uÅ¾ je hrÃ¡Ä 2 pÅ™ipojenÃ½ a jsem host, zobraz READY
        if (myPlayerNumber === 1 && game.player2_username) {
            document.getElementById('readyBtn').style.display = 'block';
        }
    }
}

function updateReadyStatus(game) {
    player1IsReady = game.player1_ready || false;
    player2IsReady = game.player2_ready || false;
    
    console.log('Ready status - P1:', player1IsReady, 'P2:', player2IsReady, 'MyPlayer:', myPlayerNumber);
    
    document.getElementById('player1Ready').textContent = player1IsReady ? 'âœ…' : 'â³';
    document.getElementById('player2Ready').textContent = player2IsReady ? 'âœ…' : 'â³';
    
    if (game.player2_username) {
        document.getElementById('player2WaitName').textContent = game.player2_username;
    }
    
    // Pokud jsou oba ready, zobraz tlaÄÃ­tko START hostu (hrÃ¡Ä 1)
    if (player1IsReady && player2IsReady) {
        console.log('Oba jsou ready!');
        if (myPlayerNumber === 1) {
            console.log('Zobrazuji tlaÄÃ­tko START pro hosta');
            document.getElementById('startBtn').style.display = 'block';
            document.getElementById('readyBtn').style.display = 'none';
        } else {
            console.log('HrÃ¡Ä 2 ÄekÃ¡ na spuÅ¡tÄ›nÃ­');
            document.getElementById('readyBtn').style.display = 'none';
        }
    }
}

async function setReady() {
    const field = myPlayerNumber === 1 ? 'player1_ready' : 'player2_ready';
    
    console.log('Nastavuji ready pro:', field);
    
    const { data, error } = await supabase
        .from('tetris_multiplayer_games')
        .update({ [field]: true })
        .eq('id', currentGameId)
        .select()
        .single();
    
    if (error) {
        console.error('Chyba pÅ™i nastavenÃ­ ready:', error);
        return;
    } else {
        console.log('Ready nastaveno ÃºspÄ›Å¡nÄ›:', data);
        updateReadyStatus(data);
    }
    
    document.getElementById('readyBtn').style.display = 'none';
}

async function startCountdown() {
    await supabase
        .from('tetris_multiplayer_games')
        .update({ status: 'countdown' })
        .eq('id', currentGameId);
    
    document.getElementById('startBtn').style.display = 'none';
    document.getElementById('readyBtn').style.display = 'none';
    
    const countdownEl = document.getElementById('countdownDisplay');
    countdownEl.style.display = 'block';
    
    let count = 10;
    countdownEl.textContent = count;
    
    const interval = setInterval(async () => {
        count--;
        if (count > 0) {
            countdownEl.textContent = count;
        } else {
            clearInterval(interval);
            countdownEl.textContent = 'START!';
            
            await supabase
                .from('tetris_multiplayer_games')
                .update({ status: 'playing' })
                .eq('id', currentGameId);
            
            setTimeout(() => {
                startGame();
            }, 500);
        }
    }, 1000);
}

async function cancelGame() {
    if (window.waitInterval) {
        clearInterval(window.waitInterval);
    }
    
    if (waitingChannel) {
        await waitingChannel.unsubscribe();
    }
    
    if (currentGameId) {
        await supabase
            .from('tetris_multiplayer_games')
            .delete()
            .eq('id', currentGameId);
    }
    
    backToMenu();
}

function backToMenu() {
    if (gameStateChannel) {
        gameStateChannel.unsubscribe();
    }
    
    gameActive = false;
    currentGameId = null;
    
    document.getElementById('mainMenu').style.display = 'flex';
    document.getElementById('joinMenu').style.display = 'none';
    document.getElementById('waitingRoom').style.display = 'none';
    document.getElementById('gameArena').style.display = 'none';
    document.getElementById('winnerOverlay').style.display = 'none';
}

async function startGame() {
    if (window.waitInterval) {
        clearInterval(window.waitInterval);
    }
    
    document.getElementById('waitingRoom').style.display = 'none';
    document.getElementById('gameArena').style.display = 'flex';
    document.getElementById('currentGameCode').textContent = currentGameCode;
    
    gameActive = true;
    
    const { data: game } = await supabase
        .from('tetris_multiplayer_games')
        .select('*')
        .eq('id', currentGameId)
        .single();
    
    document.getElementById('player1Name').textContent = `ðŸŽ® ${game.player1_username}`;
    document.getElementById('player2Name').textContent = `ðŸŽ® ${game.player2_username}`;
    
    player1 = createPlayer('grid1', 'score1', 'level1', 1, 20, 10, 'classic');
    player2 = createPlayer('grid2', 'score2', 'level2', 2, 20, 10, 'classic');
    
    const myPlayer = myPlayerNumber === 1 ? player1 : player2;
    await saveGameState(myPlayer);
    
    subscribeToGame();
    gameLoop();
}

function createPlayer(gridId, scoreId, levelId, playerNum, rows, cols, themeName) {
    const player = {
        grid: [],
        current: null,
        nextPiece: null,
        score: 0,
        level: 1,
        lines: 0,
        gameOver: false,
        dropInterval: 600,
        lastDrop: Date.now(),
        gridElement: document.getElementById(gridId),
        scoreElement: document.getElementById(scoreId),
        levelElement: document.getElementById(levelId),
        rows: rows,
        cols: cols,
        playerNumber: playerNum,
        theme: themeName
    };
    
    player.gridElement.innerHTML = '';
    player.gridElement.style.gridTemplateRows = `repeat(${rows}, 25px)`;
    player.gridElement.style.gridTemplateColumns = `repeat(${cols}, 25px)`;
    
    for (let r = 0; r < rows; r++) {
        player.grid[r] = [];
        for (let c = 0; c < cols; c++) {
            const cell = document.createElement('div');
            cell.classList.add('cell');
            player.gridElement.appendChild(cell);
            player.grid[r][c] = 0;
        }
    }
    
    player.nextPiece = randomShape();
    newPiece(player);
    
    return player;
}

function randomShape() {
    const shape = shapes[Math.floor(Math.random() * shapes.length)];
    return {
        shape: shape.shape.map(r => r.slice()),
        color: shape.color
    };
}

function newPiece(player) {
    player.current = player.nextPiece;
    player.current.x = Math.floor(player.cols / 2) - 1;
    player.current.y = 0;
    player.nextPiece = randomShape();
    
    if (collision(player)) {
        player.gameOver = true;
        const winnerNumber = player.playerNumber === 1 ? 2 : 1;
        endGame(winnerNumber);
    }
}

function collision(player, offsetX = 0, offsetY = 0) {
    for (let r = 0; r < player.current.shape.length; r++) {
        for (let c = 0; c < player.current.shape[r].length; c++) {
            if (player.current.shape[r][c]) {
                let newY = player.current.y + r + offsetY;
                let newX = player.current.x + c + offsetX;
                if (newY >= player.rows || newX < 0 || newX >= player.cols) return true;
                if (newY >= 0 && player.grid[newY][newX]) return true;
            }
        }
    }
    return false;
}

function moveDown(player) {
    if (player.gameOver) return;
    player.current.y++;
    if (collision(player)) {
        player.current.y--;
        freeze(player);
        newPiece(player);
    }
}

function freeze(player) {
    for (let r = 0; r < player.current.shape.length; r++) {
        for (let c = 0; c < player.current.shape[r].length; c++) {
            if (player.current.shape[r][c]) {
                player.grid[player.current.y + r][player.current.x + c] = player.current.color;
            }
        }
    }
    clearLines(player);
}

function clearLines(player) {
    let cleared = 0;
    for (let r = player.rows - 1; r >= 0; r--) {
        if (player.grid[r].every(cell => cell !== 0)) {
            player.grid.splice(r, 1);
            player.grid.unshift(Array(player.cols).fill(0));
            cleared++;
            r++;
        }
    }
    
    if (cleared > 0) {
        player.lines += cleared;
        player.score += cleared * 100 * player.level;
        player.level = Math.floor(player.lines / 10) + 1;
        player.dropInterval = Math.max(100, 600 - (player.level * 50));
        updateDisplay(player);
    }
}

function draw(player) {
    const cells = player.gridElement.querySelectorAll('.cell');
    
    cells.forEach(cell => {
        cell.style.background = '#1a1a2e';
        cell.style.boxShadow = 'none';
        cell.classList.remove('filled');
    });
    
    for (let r = 0; r < player.rows; r++) {
        for (let c = 0; c < player.cols; c++) {
            if (player.grid[r][c]) {
                const cell = cells[r * player.cols + c];
                const color = getColorFromTheme(player.theme, player.grid[r][c]);
                cell.style.background = color;
                cell.style.boxShadow = `0 0 8px ${color}`;
                cell.classList.add('filled');
            }
        }
    }
    
    if (player.current) {
        for (let r = 0; r < player.current.shape.length; r++) {
            for (let c = 0; c < player.current.shape[r].length; c++) {
                if (player.current.shape[r][c]) {
                    const index = (player.current.y + r) * player.cols + (player.current.x + c);
                    if (index >= 0 && index < cells.length) {
                        const color = getColorFromTheme(player.theme, player.current.color);
                        cells[index].style.background = color;
                        cells[index].style.boxShadow = `0 0 12px ${color}`;
                        cells[index].classList.add('filled');
                    }
                }
            }
        }
    }
}

function updateDisplay(player) {
    player.scoreElement.textContent = player.score;
    player.levelElement.textContent = player.level;
}

function rotate(player) {
    const shape = player.current.shape;
    const N = shape.length;
    const M = shape[0].length;
    const rotated = [];
    
    for (let y = 0; y < M; y++) {
        rotated[y] = [];
        for (let x = 0; x < N; x++) {
            rotated[y][x] = shape[N - 1 - x][y] || 0;
        }
    }
    
    const oldShape = player.current.shape;
    player.current.shape = rotated;
    
    if (collision(player)) {
        player.current.shape = oldShape;
    }
}

function hardDrop(player) {
    while (!collision(player, 0, 1)) {
        player.current.y++;
    }
    freeze(player);
    newPiece(player);
    player.score += 10;
    updateDisplay(player);
}

async function saveGameState(player) {
    if (!currentGameId || !player) return;
    
    try {
        await supabase.from('tetris_game_state').delete().eq('game_id', currentGameId).eq('player_number', player.playerNumber);
        
        await supabase.from('tetris_game_state').insert({
            game_id: currentGameId,
            player_number: player.playerNumber,
            grid: JSON.stringify(player.grid),
            current_piece: JSON.stringify(player.current),
            score: player.score,
            level: player.level,
            lines: player.lines,
            game_over: player.gameOver,
            updated_at: new Date().toISOString()
        });
    } catch (error) {
        console.error('Chyba:', error);
    }
}

function subscribeToGame() {
    gameStateChannel = supabase.channel(`game_state_${currentGameId}`)
        .on('postgres_changes', {
            event: '*',
            schema: 'public',
            table: 'tetris_game_state',
            filter: `game_id=eq.${currentGameId}`
        }, async (payload) => {
            if (payload.new.player_number !== myPlayerNumber) {
                const otherPlayer = payload.new.player_number === 1 ? player1 : player2;
                
                try {
                    otherPlayer.grid = JSON.parse(payload.new.grid);
                    otherPlayer.current = JSON.parse(payload.new.current_piece);
                } catch (e) {
                    otherPlayer.grid = payload.new.grid;
                    otherPlayer.current = payload.new.current_piece;
                }
                
                otherPlayer.score = payload.new.score;
                otherPlayer.level = payload.new.level;
                otherPlayer.gameOver = payload.new.game_over;
                
                updateDisplay(otherPlayer);
                draw(otherPlayer);
                
                if (payload.new.game_over) {
                    document.getElementById(`status${payload.new.player_number}`).textContent = 'âŒ PROHRÃL';
                    document.getElementById(`status${payload.new.player_number}`).style.color = '#f00';
                }
            }
        }).subscribe();
}

async function endGame(winnerNumber) {
    gameActive = false;
    
    const { data: game } = await supabase.from('tetris_multiplayer_games').select('*').eq('id', currentGameId).single();
    
    const winner = winnerNumber === 1 ? game.player1_username : game.player2_username;
    
    await supabase.from('tetris_multiplayer_games').update({ status: 'finished', winner: winner }).eq('id', currentGameId);
    
    const iWon = winnerNumber === myPlayerNumber;
    
    document.getElementById('winnerText').textContent = iWon ? 'ðŸŽ‰ VYHRÃL JSI! +100 ðŸ’°' : `ðŸ˜¢ ${winner} vyhrÃ¡l!`;
    document.getElementById('winnerOverlay').style.display = 'flex';
}

function gameLoop() {
    if (!gameActive) return;
    
    const now = Date.now();
    const myPlayer = myPlayerNumber === 1 ? player1 : player2;
    const otherPlayer = myPlayerNumber === 1 ? player2 : player1;
    
    if (!myPlayer.gameOver && now - myPlayer.lastDrop > myPlayer.dropInterval) {
        moveDown(myPlayer);
        draw(myPlayer);
        myPlayer.lastDrop = now;
        saveGameState(myPlayer);
    }
    
    draw(otherPlayer);
    requestAnimationFrame(gameLoop);
}

document.addEventListener('keydown', e => {
    if (!gameActive) return;
    const myPlayer = myPlayerNumber === 1 ? player1 : player2;
    if (!myPlayer || myPlayer.gameOver) return;
    
    if (e.key === 'ArrowLeft') {
        myPlayer.current.x--;
        if (collision(myPlayer)) myPlayer.current.x++;
        draw(myPlayer);
        saveGameState(myPlayer);
    }
    if (e.key === 'ArrowRight') {
        myPlayer.current.x++;
        if (collision(myPlayer)) myPlayer.current.x--;
        draw(myPlayer);
        saveGameState(myPlayer);
    }
    if (e.key === 'ArrowDown') {
        moveDown(myPlayer);
        draw(myPlayer);
        saveGameState(myPlayer);
    }
    if (e.key === 'ArrowUp') {
        rotate(myPlayer);
        draw(myPlayer);
        saveGameState(myPlayer);
    }
    if (e.key === ' ') {
        e.preventDefault();
        hardDrop(myPlayer);
        draw(myPlayer);
        saveGameState(myPlayer);
    }
});

document.getElementById('createBtn').addEventListener('click', createGame);
document.getElementById('joinBtn').addEventListener('click', showJoinMenu);
document.getElementById('joinGameBtn').addEventListener('click', joinGame);
document.getElementById('backFromJoinBtn').addEventListener('click', backToMenu);
document.getElementById('readyBtn').addEventListener('click', setReady);
document.getElementById('startBtn').addEventListener('click', startCountdown);
document.getElementById('cancelBtn').addEventListener('click', cancelGame);
document.getElementById('backBtn').addEventListener('click', () => window.location.href = 'hry.html');
document.getElementById('leaveGameBtn').addEventListener('click', () => window.location.href = 'hry.html');
document.getElementById('backToMenuBtn').addEventListener('click', backToMenu);

loadUser();
</script>
